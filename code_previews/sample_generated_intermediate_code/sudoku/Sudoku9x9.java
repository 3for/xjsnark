package xjsnark.sudoku;

/*Generated by MPS */

import backend.structure.CircuitGenerator;
import backend.config.Config;
import backend.eval.SampleRun;
import java.math.BigInteger;
import backend.auxTypes.FieldElement;
import util.Util;
import backend.auxTypes.PermutationVerifier;
import backend.eval.CircuitEvaluator;

public class Sudoku9x9 extends CircuitGenerator {



  public static void main(String[] args) {
    // This is the java main method. Its purpose is to make the Progam runnable in the environment 
    // This method can be left empty, or used to set Configuration params (see examples) 
    Config.inputVerbose = true;
    Config.debugVerbose = true;
    new Sudoku9x9();
  }

  public Sudoku9x9() {
    super("Sudoku9x9");
    __generateCircuit();
    this.__evaluateSampleRun(new SampleRun("Sample_Run1", true) {
      public void pre() {
        // A simple problem with many possible solutions, just for testing 

        // [1,2,3,4,5,6,7,8,9] 
        // [4,5,6,7,8,9],0,0,0 
        // [7,8,9],0,0,0,0,0,0 

        // [2,3,4,5,6,7,8,9],0 
        // [5,6,7,8,9],0,0,0,0 
        // [8,9],0,0,0,0,0,0,0 

        // [3,4,5,6,7,8,9],0,0 
        // [6,7,8,9],0,0,0,0,0 
        // [9],0,0,0,0,0,0,0,0 

        for (int i = 0; i < 9; i++) {
          for (int j = 0; j < 9; j++) {
            if (j < 9 - i) {
              problem[(i * 3) % 9 + i / 3][j].mapValue(BigInteger.valueOf((i + j) % 9 + 1), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
              // if the value of solution[.][.] is different from above, an assertion will fail 
              solution[(i * 3) % 9 + i / 3][j].mapValue(BigInteger.valueOf((i + j) % 9 + 1), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
            } else {
              problem[(i * 3) % 9 + i / 3][j].mapValue(BigInteger.ZERO, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
              solution[(i * 3) % 9 + i / 3][j].mapValue(BigInteger.valueOf((i + j) % 9 + 1), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
            }
          }
        }
      }
      public void post() {
        System.out.println("If no exceptions or failed assertions appear, then things should be ok");
      }

    });

  }



  public void __init() {
    problem = (FieldElement[][]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{9, 9}, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    solution = (FieldElement[][]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{9, 9}, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
  }

  private FieldElement[][] problem;
  private FieldElement[][] solution;

  @Override
  public void __defineInputs() {
    super.__defineInputs();




    problem = (FieldElement[][]) FieldElement.createInputArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(problem), new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));







  }
  @Override
  public void __defineWitnesses() {
    super.__defineWitnesses();





    solution = (FieldElement[][]) FieldElement.createWitnessArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(solution), new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));







  }
  @Override
  public void __defineVerifiedWitnesses() {
    super.__defineVerifiedWitnesses();















  }
  public void outsource() {
    // first verify that the non-zero entries in the "problem" matrix are the same in the "solution" matrix 
    for (int i = 0; i < 9; i++) {
      for (int j = 0; j < 9; j++) {
        // if problem[i][j] is not zero, then solution[i][j] must have the same value 
        CircuitGenerator.__getActiveCircuitGenerator().__forceNativeConstraint(problem[i][j].subtract(solution[i][j]), problem[i][j], FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 0));
      }
    }

    // second, check that there are no repetitions in any row, column, or subsquare 
    FieldElement[] ref = new FieldElement[]{new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("1")), new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("2")), new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("3")), new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("4")), new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("5")), new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("6")), new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("7")), new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("8")), new FieldElement(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), new BigInteger("9"))};
    for (int i = 0; i < 9; i++) {
      new PermutationVerifier(solution[i], ref, "", FieldElement.__getClassRef(), new Object[]{"21888242871839275222246405745257275088548364400416034343698204186575808495617"});
      new PermutationVerifier(getColumn(solution, i), ref, "", FieldElement.__getClassRef(), new Object[]{"21888242871839275222246405745257275088548364400416034343698204186575808495617"});
      new PermutationVerifier(getSubSquare(solution, i), ref, "", FieldElement.__getClassRef(), new Object[]{"21888242871839275222246405745257275088548364400416034343698204186575808495617"});
    }
  }
  public static FieldElement[] getColumn(FieldElement[][] array, int idx) {
    FieldElement[] col = (FieldElement[]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{array.length}, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    for (int i = 0; i < col.length; i++) {
      col[i].assign(array[i][idx]);
    }
    return col;
  }
  public static FieldElement[] getSubSquare(FieldElement[][] array, int idx) {
    FieldElement[] square = (FieldElement[]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{array.length}, new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
    int d = (int) Math.sqrt(array.length);
    int counter = 0;
    for (int i = 0; i < d; i++) {
      for (int j = 0; j < d; j++) {
        square[counter++].assign(array[i + (idx / d) * d][j + (idx % d) * d]);
      }
    }
    return square;
  }

  public void __generateSampleInput(CircuitEvaluator evaluator) {
    __generateRandomInput(evaluator);
  }

}
